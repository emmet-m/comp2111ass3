\documentclass[a4paper]{scrartcl}
\usepackage[l2tabu,orthodox]{nag}% Old habits die hard. All the same, there are commands, classes and packages which are outdated and superseded. nag provides routines to warn the user about the use of those.

\usepackage[all,error]{onlyamsmath}% Error on deprecated math commands like $$ $$.
\usepackage{fixltx2e}
\usepackage[strict=true]{csquotes}
\usepackage[usenames, dvipsnames]{color}
\usepackage[colorlinks=true]{hyperref}
\usepackage{2111defs2,2111theorems}

% Algortihms package for pretty code formatting!
\usepackage{algorithm2e}
\usepackage{algpseudocode}

\allowdisplaybreaks 

\title{\texttt{$\mathbb{C}$ase $\mathbb{S}$tudy: $\mathbb{H}$elp us oh $\mathcal{HELP}$}}
\author{$\mathbb{E}$mmet $\mathbb{M}$urray z5059840, $\mathbb{D}$anni $\mathbb{O}$vens z5059491}

% Danni's awesome and super helpful math things y@y
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\refinedby}{\sqsubseteq} % THIS IS MY PERSONAL FAV ~refined by~
\newcommand\textlcsc[1]{\textsc{\MakeLowercase{#1}}} % pretty small uppercase letters
%This is actually the best thing we've probably ever done
\newcommand{\rc}[1]{ $\refinedby$ \quad \textbf{\textcolor{ForestGreen}{$\langle$ #1 $\rangle$}}}

%I cna't live without this:
\newcommand{\squigglyBoy}{~}
\newcommand{\leftcurlyBoy}{\{}
\newcommand{\rightcurlyBoy}{\}}


% This is just fun:
\newcommand{\que}[1]{\langle #1 \rangle}
\newcommand{\explain}[1]{\textcolor{RoyalBlue}{\textit{#1}}}
\newcommand{\tabb}{\null \quad}
\newcommand{\tabbb}{\null \quad \quad}
\newcommand{\tabbbb}{\null \quad \quad \quad}

% Document starts here
\begin{document}
\maketitle
\section{BFS Implementation}
%
\subsection{Defining an abstract queue}
We will begin by defining some abstract queue operations in our toy language: \\
\begin{center}
{\LARGE{\textsc{Queue:}}\normalsize}
\end{center}
\begin{equation*}
\mathcal{Q} :: ( N:\N, ~n:\N, ~s:V_{t}^{*} ) \\
\end{equation*} \\
%
Where $N$ is the max size of the queue, $n$ is the current size, and $s$ is a sequence of queue values. \\
%
We can now define our 4 core abstract queue operations: \\ \\
%
\textbf{Initq:} \\
% Do we even need this? In Liam's example he just sets the queue to the empty queue.
$q : [True, ~ q = ( N, n, s) \land n = 0] \refinedby initq(q)$ \\
\textbf{Enq:} \\
$q : [n <= N, ~ q = ( N, n, xs_0) \land n \neq 0] \refinedby enq(q, x)$ \\
\textbf{Deq:} \\
$q,x : [n > 0, q = (N, n, s_0) \land x = s[n] \land n = n_0 - 1] \refinedby x := deq(q)$ \\
\textbf{WhosNext:} \\
$q,x : [q = (N, ys), q = q_0 \land x = y] \refinedby x := whosNext(q)$ \\
\textbf{isEmpty:} \\
$b : [q = (N, n, s), b \iff n = 0 ] \refinedby b := isEmpty(q)$\\
%
\subsection{Refinement}
We begin by refining the provided specification of \textsc{Search}: \\ \\
%
\textbf{proc }{\textsc{Search}(\textbf{value} $t$, \textbf{value} $N$, \textbf{value} $k$, \textbf{result} $v$, \textbf{result} $f$) $\cdot$\\
\[ t, N, k, v, f: \left[
    \begin{array}{l} 
	\textsc{Tree}(t) \land \text{max}_{i\in\N} | \Gamma^i_t (r_t)  \cup \Gamma^{i+1}_t (r_t) | \leq N ,\\
	(f \land \exists w \in V_{t_0} (\kappa_{t_0}(w) = k_0 \land \lambda_{t_0} (w) = v)) ~ \lor \\
	(\neg f  \land \forall w \in V_{t_0} (\kappa_{t_0}(w) \neq k_0))
    \end{array} 
\right] \] \\
%
%
\rc{c-frame} \\ 
$\null \quad \nt{v, f: \left[
    \begin{array}{l} 
	\textsc{Tree}(t) \land \text{max}_{i\in\N} | \Gamma^i_t (r_t)  \cup \Gamma^{i+1}_t (r_t) | \leq N ,\\
	(f \land \exists w \in V_{t} (\kappa_{t}(w) = k \land \lambda_{t} (w) = v)) ~ \lor \\
	(\neg f  \land \forall w \in V_{t} (\kappa_{t}(w) \neq k))
    \end{array} 
\right]}{(1)}$ \\ \\
%
\\ In order to use a breadth first search along the tree, we need a queue. Thus we must create a queue variable and initialise it to an empty queue: \\  \\
%I LOC
(1) \rc{i-loc} \explain{q doesn't occur yet} \\
\null \quad \textbf{var } q : $\mathcal{Q}~\cdot$ 
$v, f, q \left[ 
~pre(1),~
post(1)~
\right]$ \\ \\
%
%
% SEQ
\rc{seq} \explain{so we can refine to initq}\\
$ \null \quad v, f, q : \left[ 
	~ True, ~
	pre(1) \land q = (N,n,s) \land n = 0
\right]$; \\
$ \null \quad v, f, q : \left[ 	
	pre(1) \land q = (N,n,s) \land n = 0, ~
	post(1)
\right]$ \\ \\
%
%
\rc{initq} \explain{}\\
$ \null \quad initq(q);$ \\
$ \null \quad \nt{v, f, q : \left[ 	
	pre(1) \land q = (N,n,s) \land n = 0, ~
	post(1)
\right]}{(2)}$ \\ \\
%
%
Similarly, we push our initial element $r_t$ onto the queue: \\
%
(2) \rc{seq, con} \explain{We introduce a constant to freeze the value of $n$} \\
$ \null \quad \textbf{con } m \cdot v, f, q : \left[ 	
\begin{array}{l}
	pre(1) \land q = (N,n,s) \land n = 0 \land m = n,  \\
	pre(1) \land q = (N,n,r_t) \land n \neq 0 \land n = m + 1
\end{array}
\right]$; \\
$ \null \quad \quad \quad  \quad \quad v, f, q : \left[ 	
	~pre(1) \land q = (N,n,r_t) \land n \neq 0 \land n = m + 1, ~
	post(1)
\right]$ \\ \\
%
\rc{enq} \\
$ \null \quad enq(q, r_t)$; \\
$ \null \quad \nt{v, f, q : \left[ 	
	~pre(1) \land q = (N,n,r_t) \land n \neq 0 \land n = m + 1, ~
	post(1)
\right]}{(3)}$ \\ \\
%
Now we set our result flag $f$ to false so we can begin our traversal: \\ \\
%
(3) \rc{seq, ass} \explain{} \\
$ \null \quad f := False;$ \\
$ \null \quad \nt{v, f, q : \left[ 	
	pre(1) \land q = (N,n,s) \land n \neq 0 \land f = False \land n = m + 1, ~
	post(1)
\right]}{(4)}$ \\ \\
%
Now we conquer the more difficult task of refining our loop. We begin with a sequential composition: \\
%
(4) \rc{w-pre} \explain{Remove our constant m from our precondition with a w-pre} \\
$ \null \quad \nt{v, f, q : \left[ 	
	pre(1) \land q = (N,n,s) \land n \neq 0 \land f = False, ~
	post(1) ~
\right]}{(5)}$ \\
%
And now we refine (5) into our main loop: \\
%

(5) \rc{while, isEmpty}  \\
\begin{algorithm}[H]
\While {$\neg (f \lor isEmpty(q))$} {
	$v, f, q : \nt{\left[
	\begin{array}{l}
		pre(1) \land q = (N,n,s) \land \neg f \land n \neq 0, \\
		pre(1) \land q = (N,n,s)
	\end{array}
	\right]}{(6)}$
} 
\end{algorithm}

Where our loop invariant is:

\begin{equation*}
Inv : \left(
	\begin{array}{l}
		 \exists i \in \N .\Big(\forall e \in s . (e \in \Gamma^i_t(r) \cup \Gamma^{i+1}_t(r))  \\
			  \land ~ \forall z \in \Gamma^{i}_t(r). e \in \Gamma(z) \implies z \notin s \land \kappa_t(z) \notin k \Big) \\
			  \lor ~ ( \exists w \in V_t. ~w \in \Gamma_t^*(r_t) \land \kappa_t(w) = k \land \lambda_t(w) = v)
		\end{array} \right)
\end{equation*} \\
There are a few cases of the state of the queue that were unnecessary to consider due to the definition of a tree.
We are able to represent the queue's set directly as the descendants of the current node being explored as it is a precondition that all nodes have a unique parent, implying that no node can be added multiple times. This is cemented by the lack of cycles in the tree. \\ \\
Now we make the first step of getting a node to search over via \textsc{Deq}: \\ \\
(6) \rc{i-loc, seq, deq} \explain{As we have n $\neq$ 0 in the precondition of (6) we can refine into deq() using a sequential composition} \\ \\
$
\null \quad \textbf{var } t \cdot 
t := deq(q); \\
\null \quad \nt{v, f, q, t : \left[ pre(6) \land t = s[n], post(6) \right]}{(7)}
$ \\ \\
We now need a conditional to check if our current node $t$ is our goal. \\ \\
%
%
%
%
(7) \rc{if} \explain{} \\
\begin{algorithm}[H]
\eIf { $\kappa_t(t) = k$ } {
$\nt{v, f, q, t : \left[ pre(6) \land t = s[n] \land \kappa_t(t) = k, post(6) \right]}{(8)}$
} {
$\nt{v, f, q, t : \left[ pre(6) \land t = s[n] \land \kappa_t(t) \neq k, post(6) \right]}{(9)}$
}
\end{algorithm}
%
\noindent
(8) refines into our goal state, where we set the flag to true and assign the payload. \\ \\
%
%
(8) \rc{seq}  \explain{} \\
\tabb \quad $v, f, q, t : \left[ 
\begin{array}{l}
pre(6) \land t = s[n] \land \kappa_t(t) = k, \\
pre(6) \land t = s[n] \land \kappa_t(t) = k \land v = \lambda_t(t)
\end{array}
\right];$ \\ \\
\tabb \quad $v, f, q, t : \left[ ~pre(6) \land t = s[n] \land \kappa_t(t) = k \land v = \lambda_t(t), post(6) \right]$ \\ \\
%
\tabb \rc{ass} \explain{}  \\
\tabb \quad  v := $\lambda_t(t)$; \\
\tabb \quad $v, f, q, t : \left[ pre(6) \land t = s[n] \land \kappa_t(t) = k \land v = \lambda_t(t), post(6) \right]$ \\
%
\tabb \rc{s-post, ass} \explain{}  \\
\tabb \quad  v := $\lambda_t(t)$; \\
\tabb \quad  f := \textit{True} \\ \\
%
Now returning to (9), we need to enqueue all of the successors of the current node. Using the successor function $\Gamma$ to retrieve a set of all successors: \\ \\
%
(9) \rc{i-loc, seq, ass} \explain{Create a copy of the set of successors} \\
\tabb \textbf{var } succ $\cdot$
succ := $\Gamma_t(t)$; \\
\tabb $\nt{v, f, q, t, succ : \left[ pre(6) \land t = s[n] \land \kappa_t(t) \neq k \land succ = \Gamma_t(t), post(6) \right]}{(10)}$ \\\\
%
Now looping through the set, we pick an element from the set each time and enqueue it in our queue.
% l is for leaf
\begin{equation*}
\begin{array}{l}
\end{array}
\end{equation*}
%
(10) \rc{while, seq x 2, ass x 2, enq} \\
\begin{algorithm}[H]
\While {succ $\neq \varnothing$} {
\textbf{var} $l :\in succ$ \\
enq(q, l) \\
$succ := succ \setminus \{ l\}$ 
}
\end{algorithm} 
%
Now we
\end{document}



 ALGORITHM README

\begin{algorithm}[H]
 %Condition inside first brackets
\eIf {$$} {
 If part follows
$
$
}{
 Else part
$
$
}
\end{algorithm}
